import {
  app_class_default,
  clicks_default,
  create_store_default,
  deleteProps,
  device_default,
  dom7_default,
  eventNameToColonCase,
  flattenArray,
  getDevice,
  getDocument,
  getSupport,
  getWindow,
  history_default,
  id,
  isObject,
  merge,
  modal_default,
  navbar_default,
  resize_default,
  router_class_default,
  router_default,
  service_worker_default,
  statusbar_default,
  store_default,
  subnavbar_default,
  support_default,
  toolbar_default,
  touch_default,
  touch_ripple_default,
  utils_default,
  utils_exports,
  view_default
} from "./chunk-UZGNJNGD.js";
import "./chunk-PZ5AY32C.js";

// node_modules/framework7/modules/router/component-loader.js
var component_loader_default = {
  name: "routerComponentLoader",
  proto: {
    openIn(router, url, options) {
      const navigateOptions = {
        url,
        route: {
          path: url,
          options: {
            ...options,
            openIn: void 0
          }
        }
      };
      const params = {
        ...options
      };
      const component = (props, ctx) => {
        const {
          $h: $h2,
          $onMounted,
          $el,
          $f7
        } = ctx;
        $onMounted(() => {
          const viewEl = $el.value.find(".view");
          const view = $f7.view.create(viewEl, {
            linksView: router.view.selector,
            ignoreOpenIn: true,
            loadInitialPage: false
          });
          view.router.navigate(url, {
            props: options.props,
            reloadAll: true
          });
        });
        return () => {
          if (options.openIn === "popup") {
            return $h2`<div class="popup popup-router-open-in" data-url="${url}"><div class="view"></div></div>`;
          }
          if (options.openIn === "loginScreen") {
            return $h2`<div class="login-screen login-screen-router-open-in" data-url="${url}"><div class="view"></div></div>`;
          }
          if (options.openIn === "sheet") {
            return $h2`<div class="sheet-modal sheet-modal-router-open-in" data-url="${url}"><div class="sheet-modal-inner"><div class="view"></div></div></div>`;
          }
          if (options.openIn === "popover") {
            return $h2`<div class="popover popover-router-open-in" data-url="${url}"><div class="popover-inner"><div class="view"></div></div></div>`;
          }
          if (options.openIn.indexOf("panel") >= 0) {
            const parts = options.openIn.split(":");
            const side = parts[1] || "left";
            const effect = parts[2] || "cover";
            return $h2`<div class="panel panel-router-open-in panel-${side} panel-${effect}" data-url="${url}"><div class="view"></div></div>`;
          }
        };
      };
      if (options.openIn === "popup") {
        navigateOptions.route.popup = params;
      }
      if (options.openIn === "loginScreen") {
        navigateOptions.route.loginScreen = params;
      }
      if (options.openIn === "sheet") {
        navigateOptions.route.sheet = params;
      }
      if (options.openIn === "popover") {
        params.targetEl = options.clickedEl || options.targetEl;
        navigateOptions.route.popover = params;
      }
      if (options.openIn.indexOf("panel") >= 0) {
        params.targetEl = options.clickedEl || options.targetEl;
        navigateOptions.route.panel = params;
      }
      params.component = component;
      return router.navigate(navigateOptions);
    },
    componentLoader(component, componentUrl, options, resolve, reject) {
      if (options === void 0) {
        options = {};
      }
      const router = this;
      const {
        app
      } = router;
      const url = typeof component === "string" ? component : componentUrl;
      const compiledUrl = router.replaceRequestUrlParams(url, options);
      function compile(componentFunction) {
        let context = options.context || {};
        if (typeof context === "function") context = context.call(router);
        else if (typeof context === "string") {
          try {
            context = JSON.parse(context);
          } catch (err) {
            reject(err);
            throw err;
          }
        }
        const componentContext = merge({}, context, {
          f7route: options.route,
          f7router: router
        });
        const componentProps = merge(options.route ? options.route.params || {} : {}, options.props || {}, options.routeProps || {});
        let componentEl;
        let componentRoot;
        if (options.componentOptions && options.componentOptions.el) {
          componentEl = options.componentOptions.el;
        }
        if (options.componentOptions && options.componentOptions.root) {
          componentRoot = options.componentOptions.root;
        }
        app.component.create(componentFunction, componentProps, {
          context: componentContext,
          el: componentEl,
          root: componentRoot
        }).then((createdComponent) => {
          resolve(createdComponent.el);
        }).catch((err) => {
          reject(err);
          throw new Error(err, {
            cause: err
          });
        });
      }
      let cachedComponent;
      if (compiledUrl && router.params.componentCache) {
        router.cache.components.forEach((cached) => {
          if (cached.url === compiledUrl) cachedComponent = cached.component;
        });
      }
      if (compiledUrl && cachedComponent) {
        compile(cachedComponent);
      } else if (compiledUrl && !cachedComponent) {
        if (router.xhrAbortController) {
          router.xhrAbortController.abort();
          router.xhrAbortController = false;
        }
        router.xhrRequest(url, options).then((loadedComponent) => {
          const parsedComponent = app.component.parse(loadedComponent);
          if (router.params.componentCache) {
            router.cache.components.push({
              url: compiledUrl,
              component: parsedComponent
            });
          }
          compile(parsedComponent);
        }).catch((err) => {
          reject();
          throw err;
        });
      } else {
        compile(component);
      }
    },
    modalComponentLoader(_temp) {
      let {
        component,
        componentUrl,
        options,
        resolve,
        reject
      } = _temp === void 0 ? {} : _temp;
      const router = this;
      router.componentLoader(component, componentUrl, options, (el) => {
        resolve(el);
      }, reject);
    },
    tabComponentLoader(_temp2) {
      let {
        component,
        componentUrl,
        options,
        resolve,
        reject
      } = _temp2 === void 0 ? {} : _temp2;
      const router = this;
      router.componentLoader(component, componentUrl, options, (el) => {
        resolve(el);
      }, reject);
    },
    pageComponentLoader(_temp3) {
      let {
        component,
        componentUrl,
        options,
        resolve,
        reject
      } = _temp3 === void 0 ? {} : _temp3;
      const router = this;
      router.componentLoader(component, componentUrl, options, function(el, newOptions) {
        if (newOptions === void 0) {
          newOptions = {};
        }
        resolve(el, newOptions);
      }, reject);
    }
  }
};

// node_modules/htm/dist/htm.module.js
var n = function(t2, s, r, e) {
  var u;
  s[0] = 0;
  for (var h3 = 1; h3 < s.length; h3++) {
    var p = s[h3++], a = s[h3] ? (s[0] |= p ? 1 : 2, r[s[h3++]]) : s[++h3];
    3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h3]] = a : 6 === p ? e[1][s[++h3]] += a + "" : p ? (u = t2.apply(a, n(t2, a, r, ["", null])), e.push(u), a[0] ? s[0] |= 2 : (s[h3 - 2] = 0, s[h3] = u)) : e.push(a);
  }
  return e;
};
var t = /* @__PURE__ */ new Map();
function htm_module_default(s) {
  var r = t.get(this);
  return r || (r = /* @__PURE__ */ new Map(), t.set(this, r)), (r = n(this, r.get(s) || (r.set(s, r = function(n2) {
    for (var t2, s2, r2 = 1, e = "", u = "", h3 = [0], p = function(n3) {
      1 === r2 && (n3 || (e = e.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h3.push(0, n3, e) : 3 === r2 && (n3 || e) ? (h3.push(3, n3, e), r2 = 2) : 2 === r2 && "..." === e && n3 ? h3.push(4, n3, 0) : 2 === r2 && e && !n3 ? h3.push(5, 0, true, e) : r2 >= 5 && ((e || !n3 && 5 === r2) && (h3.push(r2, 0, e, s2), r2 = 6), n3 && (h3.push(r2, n3, 0, s2), r2 = 6)), e = "";
    }, a = 0; a < n2.length; a++) {
      a && (1 === r2 && p(), p(a));
      for (var l = 0; l < n2[a].length; l++) t2 = n2[a][l], 1 === r2 ? "<" === t2 ? (p(), h3 = [h3], r2 = 3) : e += t2 : 4 === r2 ? "--" === e && ">" === t2 ? (r2 = 1, e = "") : e = t2 + e[0] : u ? t2 === u ? u = "" : e += t2 : '"' === t2 || "'" === t2 ? u = t2 : ">" === t2 ? (p(), r2 = 1) : r2 && ("=" === t2 ? (r2 = 5, s2 = e, e = "") : "/" === t2 && (r2 < 5 || ">" === n2[a][l + 1]) ? (p(), 3 === r2 && (h3 = h3[0]), r2 = h3, (h3 = h3[0]).push(2, 0, r2), r2 = 0) : " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2 ? (p(), r2 = 2) : e += t2), 3 === r2 && "!--" === e && (r2 = 4, h3 = h3[0]);
    }
    return p(), h3;
  }(s)), r), arguments, [])).length > 1 ? r : r[0];
}

// node_modules/framework7/modules/component/$h.js
var ignoreChildren = [false, null, "", void 0];
var h = function(type, props) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }
  return {
    type,
    props: props || {},
    children: flattenArray(children.filter((child) => ignoreChildren.indexOf(child) < 0))
  };
};
var $h = htm_module_default.bind(h);
var h_default = $h;

// node_modules/framework7/modules/component/snabbdom/vnode.js
function vnode(sel, data, children, text, elm) {
  var key = data === void 0 ? void 0 : data.key;
  return {
    sel,
    data,
    children,
    text,
    elm,
    key
  };
}
var vnode_default = vnode;

// node_modules/framework7/modules/component/snabbdom/is.js
var array = Array.isArray;
function primitive(s) {
  return typeof s === "string" || typeof s === "number";
}

// node_modules/framework7/modules/component/snabbdom/h.js
function addNS(data, children, sel) {
  data.ns = "http://www.w3.org/2000/svg";
  if (sel !== "foreignObject" && children !== void 0) {
    for (var i = 0; i < children.length; ++i) {
      var childData = children[i].data;
      if (childData !== void 0) {
        addNS(childData, children[i].children, children[i].sel);
      }
    }
  }
}
function h2(sel, b, c) {
  var data = {}, children, text, i;
  if (c !== void 0) {
    data = b;
    if (array(c)) {
      children = c;
    } else if (primitive(c)) {
      text = c;
    } else if (c && c.sel) {
      children = [c];
    }
  } else if (b !== void 0) {
    if (array(b)) {
      children = b;
    } else if (primitive(b)) {
      text = b;
    } else if (b && b.sel) {
      children = [b];
    } else {
      data = b;
    }
  }
  if (array(children)) {
    for (i = 0; i < children.length; ++i) {
      if (primitive(children[i])) children[i] = vnode(void 0, void 0, void 0, children[i], void 0);
    }
  }
  if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
    addNS(data, children, sel);
  }
  return vnode(sel, data, children, text, void 0);
}
var h_default2 = h2;

// node_modules/framework7/modules/component/custom-components.js
var custom_components_default = {};

// node_modules/framework7/modules/component/vdom.js
var SELF_CLOSING = "area base br col command embed hr img input keygen link menuitem meta param source track wbr".split(" ");
var PROPS_ATTRS = "hidden checked disabled readonly selected autofocus autoplay required multiple value indeterminate routeProps innerHTML".split(" ");
var BOOLEAN_PROPS = "hidden checked disabled readonly selected autofocus autoplay required multiple readOnly indeterminate".split(" ");
var getTagName = (treeNode) => {
  return typeof treeNode.type === "function" ? treeNode.type.name || "CustomComponent" : treeNode.type;
};
var toCamelCase = (name) => {
  return name.split("-").map((word, index) => {
    if (index === 0) return word.toLowerCase();
    return word[0].toUpperCase() + word.substr(1);
  }).join("");
};
var propsFromAttrs = function() {
  const context = {};
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  args.forEach(function(obj) {
    if (obj === void 0) {
      obj = {};
    }
    Object.keys(obj).forEach((key) => {
      context[toCamelCase(key)] = obj[key];
    });
  });
  return context;
};
var createCustomComponent = (_ref) => {
  let {
    f7,
    treeNode,
    vnode: vnode2,
    data
  } = _ref;
  const component = typeof treeNode.type === "function" ? treeNode.type : custom_components_default[treeNode.type];
  f7.component.create(component, propsFromAttrs(data.attrs || {}, data.props || {}), {
    el: vnode2.elm,
    children: treeNode.children
  }).then((c) => {
    if (vnode2.data && vnode2.data.on && c && c.$el) {
      Object.keys(vnode2.data.on).forEach((eventName) => {
        c.$el.on(eventName, vnode2.data.on[eventName]);
      });
    }
    vnode2.elm.__component__ = c;
  });
};
var updateCustomComponent = (vnode2) => {
  const component = vnode2 && vnode2.elm && vnode2.elm.__component__;
  if (!component) return;
  const newProps = propsFromAttrs(vnode2.data.attrs || {}, vnode2.data.props || {});
  component.children = vnode2.data.treeNode.children;
  Object.assign(component.props, newProps);
  component.update();
};
var destroyCustomComponent = (vnode2) => {
  const component = vnode2 && vnode2.elm && vnode2.elm.__component__;
  if (component) {
    const {
      el,
      $el
    } = component;
    if (vnode2.data && vnode2.data.on && $el) {
      Object.keys(vnode2.data.on).forEach((eventName) => {
        $el.off(eventName, vnode2.data.on[eventName]);
      });
    }
    if (component.destroy) component.destroy();
    if (el && el.parentNode) el.parentNode.removeChild(el);
    delete vnode2.elm.__component__;
  }
};
var isCustomComponent = (treeNodeType) => {
  return typeof treeNodeType === "function" || treeNodeType && treeNodeType.indexOf("-") > 0 && custom_components_default[treeNodeType];
};
function getHooks(treeNode, data, f7, initial, isRoot) {
  const hooks2 = {};
  const insert = [];
  const destroy = [];
  const update = [];
  const postpatch = [];
  let isFakeElement = false;
  let tagName2 = getTagName(treeNode);
  if (data && data.attrs && data.attrs.component) {
    tagName2 = data.attrs.component;
    delete data.attrs.component;
    isFakeElement = true;
  }
  const isCustom = isCustomComponent(treeNode.type);
  if (isCustom) {
    insert.push((vnode2) => {
      if (vnode2.sel !== tagName2 && !isFakeElement) return;
      createCustomComponent({
        f7,
        treeNode,
        vnode: vnode2,
        data
      });
    });
    destroy.push((vnode2) => {
      destroyCustomComponent(vnode2);
    });
    update.push((oldVnode, vnode2) => {
      updateCustomComponent(vnode2);
    });
  }
  if (!isCustom) {
    if (!data || !data.attrs || !data.attrs.class) return hooks2;
    const classNames = data.attrs.class;
    classNames.split(" ").forEach((className) => {
      if (!initial) {
        insert.push(...f7.getVnodeHooks("insert", className));
      }
      destroy.push(...f7.getVnodeHooks("destroy", className));
      update.push(...f7.getVnodeHooks("update", className));
      postpatch.push(...f7.getVnodeHooks("postpatch", className));
    });
  }
  if (isRoot && !initial) {
    postpatch.push((oldVnode, vnode2) => {
      const vn = vnode2 || oldVnode;
      if (!vn) return;
      if (vn.data && vn.data.component) {
        vn.data.component.hook("onUpdated");
      }
    });
  }
  if (insert.length === 0 && destroy.length === 0 && update.length === 0 && postpatch.length === 0) {
    return hooks2;
  }
  if (insert.length) {
    hooks2.insert = (vnode2) => {
      insert.forEach((f) => f(vnode2));
    };
  }
  if (destroy.length) {
    hooks2.destroy = (vnode2) => {
      destroy.forEach((f) => f(vnode2));
    };
  }
  if (update.length) {
    hooks2.update = (oldVnode, vnode2) => {
      update.forEach((f) => f(oldVnode, vnode2));
    };
  }
  if (postpatch.length) {
    hooks2.postpatch = (oldVnode, vnode2) => {
      postpatch.forEach((f) => f(oldVnode, vnode2));
    };
  }
  return hooks2;
}
var getEventHandler = function(eventHandler, _temp) {
  let {
    stop,
    prevent,
    once
  } = _temp === void 0 ? {} : _temp;
  let fired = false;
  function handler() {
    const e = arguments.length <= 0 ? void 0 : arguments[0];
    if (once && fired) return;
    if (stop) e.stopPropagation();
    if (prevent) e.preventDefault();
    fired = true;
    eventHandler(...arguments);
  }
  return handler;
};
var getData = (treeNode, component, f7, initial, isRoot) => {
  const data = {
    component,
    treeNode
  };
  const tagName2 = getTagName(treeNode);
  Object.keys(treeNode.props).forEach((attrName) => {
    const attrValue = treeNode.props[attrName];
    if (typeof attrValue === "undefined") return;
    if (PROPS_ATTRS.indexOf(attrName) >= 0) {
      if (!data.props) data.props = {};
      if (attrName === "readonly") {
        attrName = "readOnly";
      }
      if (attrName === "routeProps") {
        attrName = "f7RouteProps";
      }
      if (tagName2 === "option" && attrName === "value") {
        if (!data.attrs) data.attrs = {};
        data.attrs.value = attrValue;
      }
      if (BOOLEAN_PROPS.indexOf(attrName) >= 0) {
        data.props[attrName] = attrValue === false ? false : true;
      } else {
        data.props[attrName] = attrValue;
      }
    } else if (attrName === "key") {
      data.key = attrValue;
    } else if (attrName.indexOf("@") === 0 || attrName.indexOf("on") === 0 && attrName.length > 2) {
      if (!data.on) data.on = {};
      let eventName = attrName.indexOf("@") === 0 ? attrName.substr(1) : eventNameToColonCase(attrName.substr(2));
      let stop = false;
      let prevent = false;
      let once = false;
      if (eventName.indexOf(".") >= 0) {
        eventName.split(".").forEach((eventNamePart, eventNameIndex) => {
          if (eventNameIndex === 0) eventName = eventNamePart;
          else {
            if (eventNamePart === "stop") stop = true;
            if (eventNamePart === "prevent") prevent = true;
            if (eventNamePart === "once") once = true;
          }
        });
      }
      data.on[eventName] = getEventHandler(attrValue, {
        stop,
        prevent,
        once
      });
    } else if (attrName === "style") {
      if (typeof attrValue !== "string") {
        data.style = attrValue;
      } else {
        if (!data.attrs) data.attrs = {};
        data.attrs.style = attrValue;
      }
    } else {
      if (!data.attrs) data.attrs = {};
      data.attrs[attrName] = attrValue;
      if (attrName === "id" && !data.key && !isRoot) {
        data.key = attrValue;
      }
    }
  });
  const hooks2 = getHooks(treeNode, data, f7, initial, isRoot);
  hooks2.prepatch = (oldVnode, vnode2) => {
    if (!oldVnode || !vnode2) return;
    if (oldVnode && oldVnode.data && oldVnode.data.props) {
      Object.keys(oldVnode.data.props).forEach((key) => {
        if (BOOLEAN_PROPS.indexOf(key) < 0) return;
        if (!vnode2.data) vnode2.data = {};
        if (!vnode2.data.props) vnode2.data.props = {};
        if (oldVnode.data.props[key] === true && !(key in vnode2.data.props)) {
          vnode2.data.props[key] = false;
        }
      });
    }
  };
  data.hook = hooks2;
  return data;
};
var getChildren = (treeNode, component, f7, initial) => {
  if (treeNode && treeNode.type && SELF_CLOSING.indexOf(treeNode.type) >= 0) {
    return [];
  }
  const children = [];
  const nodes = treeNode.children;
  for (let i = 0; i < nodes.length; i += 1) {
    const childNode = nodes[i];
    const child = treeNodeToVNode(childNode, component, f7, initial, false);
    if (Array.isArray(child)) {
      children.push(...child);
    } else if (child) {
      children.push(child);
    }
  }
  return children;
};
var getSlots = (treeNode, component, f7, initial) => {
  const slotName = treeNode.props.name || "default";
  const slotNodes = (component.children || []).filter((childTreeNode) => {
    let childSlotName = "default";
    if (childTreeNode.props) {
      childSlotName = childTreeNode.props.slot || "default";
    }
    return childSlotName === slotName;
  });
  if (slotNodes.length === 0) {
    return getChildren(treeNode, component, f7, initial);
  }
  return slotNodes.map((subTreeNode) => treeNodeToVNode(subTreeNode, component, f7, initial));
};
var isTreeNode = (treeNode) => {
  return isObject(treeNode) && "props" in treeNode && "type" in treeNode && "children" in treeNode;
};
var treeNodeToVNode = (treeNode, component, f7, initial, isRoot) => {
  if (!isTreeNode(treeNode)) {
    return String(treeNode);
  }
  if (treeNode.type === "slot") {
    return getSlots(treeNode, component, f7, initial);
  }
  const data = getData(treeNode, component, f7, initial, isRoot);
  const children = isCustomComponent(treeNode.type) ? [] : getChildren(treeNode, component, f7, initial);
  return h_default2(getTagName(treeNode), data, children);
};
function vdom(tree, component, initial) {
  if (tree === void 0) {
    tree = {};
  }
  return treeNodeToVNode(tree, component, component.f7, initial, true);
}

// node_modules/framework7/modules/component/snabbdom/htmldomapi.js
function createElement(tagName2) {
  return document.createElement(tagName2);
}
function createElementNS(namespaceURI, qualifiedName) {
  return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
  return document.createTextNode(text);
}
function createComment(text) {
  return document.createComment(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  if (referenceNode && referenceNode.parentNode !== parentNode2) {
    if (referenceNode.__component__) referenceNode = referenceNode.__component__.el;
  }
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  if (!node) return;
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function tagName(elm) {
  return elm.tagName;
}
function setTextContent(node, text) {
  node.textContent = text;
}
function getTextContent(node) {
  return node.textContent;
}
function isElement(node) {
  return node.nodeType === 1;
}
function isText(node) {
  return node.nodeType === 3;
}
function isComment(node) {
  return node.nodeType === 8;
}
var htmlDomApi = {
  createElement,
  createElementNS,
  createTextNode,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  getTextContent,
  isElement,
  isText,
  isComment
};
var htmldomapi_default = htmlDomApi;

// node_modules/framework7/modules/component/snabbdom/snabbdom.js
function isUndef(s) {
  return s === void 0;
}
function isDef(s) {
  return s !== void 0;
}
var emptyNode = vnode_default("", {}, [], void 0, void 0);
function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode2) {
  return vnode2.sel !== void 0;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, map = {}, key, ch;
  for (i = beginIdx; i <= endIdx; ++i) {
    ch = children[i];
    if (ch != null) {
      key = ch.key;
      if (key !== void 0) map[key] = i;
    }
  }
  return map;
}
var hooks = ["create", "update", "remove", "destroy", "pre", "post"];
function init(modules, domApi) {
  var i, j, cbs = {};
  var api = domApi !== void 0 ? domApi : htmldomapi_default;
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      var hook = modules[j][hooks[i]];
      if (hook !== void 0) {
        cbs[hooks[i]].push(hook);
      }
    }
  }
  function emptyNodeAt(elm) {
    var id2 = elm.id ? "#" + elm.id : "";
    var c = elm.className ? "." + elm.className.split(" ").join(".") : "";
    return vnode_default(api.tagName(elm).toLowerCase() + id2 + c, {}, [], void 0, elm);
  }
  function createRmCb(childElm, listeners) {
    return function rmCb() {
      if (--listeners === 0) {
        var parent_1 = api.parentNode(childElm);
        api.removeChild(parent_1, childElm);
      }
    };
  }
  function createElm(vnode2, insertedVnodeQueue) {
    var i2, data = vnode2.data;
    if (data !== void 0) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.init)) {
        i2(vnode2);
        data = vnode2.data;
      }
    }
    var children = vnode2.children, sel = vnode2.sel;
    if (sel === "!") {
      if (isUndef(vnode2.text)) {
        vnode2.text = "";
      }
      vnode2.elm = api.createComment(vnode2.text);
    } else if (sel !== void 0) {
      var hashIdx = sel.indexOf("#");
      var dotIdx = sel.indexOf(".", hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      var elm = vnode2.elm = isDef(data) && isDef(i2 = data.ns) ? api.createElementNS(i2, tag) : api.createElement(tag);
      if (hash < dot) elm.setAttribute("id", sel.slice(hash + 1, dot));
      if (dotIdx > 0) elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
      for (i2 = 0; i2 < cbs.create.length; ++i2) cbs.create[i2](emptyNode, vnode2);
      if (array(children)) {
        for (i2 = 0; i2 < children.length; ++i2) {
          var ch = children[i2];
          if (ch != null) {
            api.appendChild(elm, createElm(ch, insertedVnodeQueue));
          }
        }
      } else if (primitive(vnode2.text)) {
        api.appendChild(elm, api.createTextNode(vnode2.text));
      }
      i2 = vnode2.data.hook;
      if (isDef(i2)) {
        if (i2.create) i2.create(emptyNode, vnode2);
        if (i2.insert) insertedVnodeQueue.push(vnode2);
      }
    } else {
      vnode2.elm = api.createTextNode(vnode2.text);
    }
    return vnode2.elm;
  }
  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }
  function invokeDestroyHook(vnode2) {
    var i2, j2, data = vnode2.data;
    if (data !== void 0) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.destroy)) i2(vnode2);
      for (i2 = 0; i2 < cbs.destroy.length; ++i2) cbs.destroy[i2](vnode2);
      if (vnode2.children !== void 0) {
        for (j2 = 0; j2 < vnode2.children.length; ++j2) {
          i2 = vnode2.children[j2];
          if (i2 != null && typeof i2 !== "string") {
            invokeDestroyHook(i2);
          }
        }
      }
    }
  }
  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (i_1 = 0; i_1 < cbs.remove.length; ++i_1) cbs.remove[i_1](ch, rm);
          if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
            i_1(ch, rm);
          } else {
            rm();
          }
        } else {
          api.removeChild(parentElm, ch.elm);
        }
      }
    }
  }
  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    var oldStartIdx = 0, newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx;
    var idxInOld;
    var elmToMove;
    var before;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (oldKeyToIdx === void 0) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) {
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          } else {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = void 0;
            api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }
  function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
    var i2, hook2;
    if (isDef(i2 = vnode2.data) && isDef(hook2 = i2.hook) && isDef(i2 = hook2.prepatch)) {
      i2(oldVnode, vnode2);
    }
    var elm = vnode2.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode2.children;
    if (oldVnode === vnode2) return;
    if (vnode2.data !== void 0) {
      for (i2 = 0; i2 < cbs.update.length; ++i2) cbs.update[i2](oldVnode, vnode2);
      i2 = vnode2.data.hook;
      if (isDef(i2) && isDef(i2 = i2.update)) i2(oldVnode, vnode2);
    }
    if (isUndef(vnode2.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, "");
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode2.text) {
      api.setTextContent(elm, vnode2.text);
    }
    if (isDef(hook2) && isDef(i2 = hook2.postpatch)) {
      i2(oldVnode, vnode2);
    }
  }
  return function patch2(oldVnode, vnode2) {
    var i2, elm, parent;
    var insertedVnodeQueue = [];
    for (i2 = 0; i2 < cbs.pre.length; ++i2) cbs.pre[i2]();
    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    }
    if (sameVnode(oldVnode, vnode2)) {
      patchVnode(oldVnode, vnode2, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent = api.parentNode(elm);
      createElm(vnode2, insertedVnodeQueue);
      if (parent !== null) {
        api.insertBefore(parent, vnode2.elm, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }
    for (i2 = 0; i2 < insertedVnodeQueue.length; ++i2) {
      insertedVnodeQueue[i2].data.hook.insert(insertedVnodeQueue[i2]);
    }
    for (i2 = 0; i2 < cbs.post.length; ++i2) cbs.post[i2]();
    return vnode2;
  };
}

// node_modules/framework7/modules/component/snabbdom/modules/attributes.js
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var colonChar = 58;
var xChar = 120;
function updateAttrs(oldVnode, vnode2) {
  var key, elm = vnode2.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode2.data.attrs;
  if (!oldAttrs && !attrs) return;
  if (oldAttrs === attrs) return;
  oldAttrs = oldAttrs || {};
  attrs = attrs || {};
  for (key in attrs) {
    var cur = attrs[key];
    var old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");
      } else if (cur === false) {
        elm.removeAttribute(key);
      } else {
        if (key.charCodeAt(0) !== xChar) {
          elm.setAttribute(key, cur);
        } else if (key.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(xmlNS, key, cur);
        } else if (key.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(xlinkNS, key, cur);
        } else {
          elm.setAttribute(key, cur);
        }
      }
    }
  }
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
var attributesModule = {
  create: updateAttrs,
  update: updateAttrs
};
var attributes_default = attributesModule;

// node_modules/framework7/modules/component/snabbdom/modules/props.js
function updateProps(oldVnode, vnode2) {
  var key, cur, old, elm = vnode2.elm, oldProps = oldVnode.data.props, props = vnode2.data.props;
  if (!oldProps && !props) return;
  if (oldProps === props) return;
  oldProps = oldProps || {};
  props = props || {};
  for (key in oldProps) {
    if (!props[key]) {
      delete elm[key];
    }
  }
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== "value" || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}
var propsModule = {
  create: updateProps,
  update: updateProps
};
var props_default = propsModule;

// node_modules/framework7/modules/component/snabbdom/modules/style.js
var raf = typeof window !== "undefined" && window.requestAnimationFrame || setTimeout;
var nextFrame = function(fn) {
  raf(function() {
    raf(fn);
  });
};
function setNextFrame(obj, prop, val) {
  nextFrame(function() {
    obj[prop] = val;
  });
}
function updateStyle(oldVnode, vnode2) {
  var cur, name, elm = vnode2.elm, oldStyle = oldVnode.data.style, style = vnode2.data.style;
  if (!oldStyle && !style) return;
  if (oldStyle === style) return;
  oldStyle = oldStyle || {};
  style = style || {};
  var oldHasDel = "delayed" in oldStyle;
  for (name in oldStyle) {
    if (!style[name]) {
      if (name[0] === "-" && name[1] === "-") {
        elm.style.removeProperty(name);
      } else {
        elm.style[name] = "";
      }
    }
  }
  for (name in style) {
    cur = style[name];
    if (name === "delayed" && style.delayed) {
      for (var name2 in style.delayed) {
        cur = style.delayed[name2];
        if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
          setNextFrame(elm.style, name2, cur);
        }
      }
    } else if (name !== "remove" && cur !== oldStyle[name]) {
      if (name[0] === "-" && name[1] === "-") {
        elm.style.setProperty(name, cur);
      } else {
        elm.style[name] = cur;
      }
    }
  }
}
function applyDestroyStyle(vnode2) {
  var style, name, elm = vnode2.elm, s = vnode2.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}
function applyRemoveStyle(vnode2, rm) {
  var s = vnode2.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name, elm = vnode2.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle["transition-property"].split(", ");
  for (; i < props.length; ++i) {
    if (applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener("transitionend", function(ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}
var styleModule = {
  create: updateStyle,
  update: updateStyle,
  destroy: applyDestroyStyle,
  remove: applyRemoveStyle
};
var style_default = styleModule;

// node_modules/framework7/modules/component/eventslisteners.js
function invokeHandler(handler, event, args) {
  if (typeof handler === "function") {
    handler(event, ...args);
  }
}
function handleEvent(event, args, vnode2) {
  const name = event.type;
  const on = vnode2.data.on;
  if (on && on[name]) {
    invokeHandler(on[name], event, args, vnode2);
  }
}
function createListener() {
  return function handler(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    handleEvent(event, args, handler.vnode);
  };
}
function updateEvents(oldVnode, vnode2) {
  const oldOn = oldVnode.data.on;
  const oldListener = oldVnode.listener;
  const oldElm = oldVnode.elm;
  const on = vnode2 && vnode2.data.on;
  const elm = vnode2 && vnode2.elm;
  if (oldOn === on) {
    return;
  }
  if (oldOn && oldListener) {
    if (!on) {
      Object.keys(oldOn).forEach((name) => {
        dom7_default(oldElm).off(name, oldListener);
      });
    } else {
      Object.keys(oldOn).forEach((name) => {
        if (!on[name]) {
          dom7_default(oldElm).off(name, oldListener);
        }
      });
    }
  }
  if (on) {
    const listener = oldVnode.listener || createListener();
    vnode2.listener = listener;
    listener.vnode = vnode2;
    if (!oldOn) {
      Object.keys(on).forEach((name) => {
        dom7_default(elm).on(name, listener);
      });
    } else {
      Object.keys(on).forEach((name) => {
        if (!oldOn[name]) {
          dom7_default(elm).on(name, listener);
        }
      });
    }
  }
}
var eventslisteners_default = {
  create: updateEvents,
  update: updateEvents,
  destroy: updateEvents
};

// node_modules/framework7/modules/component/patch.js
var patch = init([attributes_default, props_default, style_default, eventslisteners_default]);
var patch_default = patch;

// node_modules/framework7/modules/component/$jsx.js
var ignoreChildren2 = [false, null, "", void 0];
var $jsx = function(type, props) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }
  const flatChildren = flattenArray((children || []).filter((child) => ignoreChildren2.indexOf(child) < 0));
  if (type === "Fragment") {
    return flatChildren;
  }
  return {
    type,
    props: props || {},
    children: flatChildren
  };
};
var jsx_default = $jsx;

// node_modules/framework7/modules/component/component-class.js
var types = [{
  name: "array",
  init: (i) => i,
  type: (i) => [i].find(Array.isArray),
  update: (i, o) => [o].filter(Array.isArray).find(() => (i.length = 0, i.push(...o))),
  insert: function(i, x, o) {
    if (o === void 0) {
      o = [];
    }
    return i.splice(Math.max(x, 0), 0, ...[o].flat());
  },
  replace: function(i, x, o) {
    if (o === void 0) {
      o = [];
    }
    return i.splice(Math.max(x, 0), Math.min(++x, 1), ...[o].flat());
  },
  append: function(i, o) {
    if (o === void 0) {
      o = [];
    }
    return i.push(...[o].flat());
  },
  prepend: function(i, o) {
    if (o === void 0) {
      o = [];
    }
    return i.unshift(...[o].flat());
  },
  swap: (i, a, b) => {
    [i[a], i[b]] = [i[b], i[a]];
  },
  fromTo: function(i, a, b) {
    if (b === void 0) {
      b = a;
    }
    return i.splice(Math.max(b, 0), 0, ...i.splice(Math.max(a, 0), 1));
  },
  remove: function(i, o, a) {
    if (a === void 0) {
      a = i.map((_, x) => x);
    }
    return [o].flat().filter((i2) => a.includes(i2)).sort((a2, b) => b - a2).forEach((x) => i.splice(x, 1));
  },
  clear: (i) => i.length = 0
}, {
  name: "object",
  init: (i) => i,
  type: (i) => [i].filter((i2) => [i2 !== null, i2 !== void 0].every((i3) => i3)).find((i2) => Object.getPrototypeOf(i2) === Object.prototype),
  update: (i, o) => Object.assign(i, o),
  insert: () => {
  },
  replace: () => {
  },
  append: () => {
  },
  prepend: () => {
  },
  swap: () => ({}),
  // N/A
  fromTo: () => ({}),
  // N/A
  remove: (i, o) => [o].flat().forEach((k) => delete i[k]),
  clear: (i) => Object.keys(i).forEach((k) => delete i[k])
}, {
  name: "atoms",
  type: () => true,
  init: function(i, o) {
    if (o === void 0) {
      o = {};
    }
    return Object.defineProperty(o, "value", {
      get: () => i,
      set: (v) => {
        i = v;
      }
    }), o;
  },
  update: function(i, v) {
    if (v === void 0) {
      v = i.value;
    }
    i.value = v;
  },
  insert: () => ({}),
  // N/A
  replace: () => ({}),
  // N/A
  append: () => ({}),
  // N/A
  prepend: () => ({}),
  // N/A
  swap: () => ({}),
  // N/A
  fromTo: () => ({}),
  // N/A
  remove: () => ({}),
  // N/A
  clear: (i) => {
    i.value = void 0;
  }
}];
var Component = class {
  constructor(app, component, props, _temp) {
    if (props === void 0) {
      props = {};
    }
    let {
      el,
      context,
      children
    } = _temp === void 0 ? {} : _temp;
    const document2 = getDocument();
    merge(this, {
      f7: app,
      props: props || {},
      context: context || {},
      id: component.id || id(),
      children: children || [],
      theme: {
        ios: app.theme === "ios",
        md: app.theme === "md"
      },
      style: component.style,
      __updateQueue: [],
      __eventHandlers: [],
      __onceEventHandlers: [],
      __onBeforeMount: [],
      __onMounted: [],
      __onBeforeUpdate: [],
      __onUpdated: [],
      __onBeforeUnmount: [],
      __onUnmounted: []
    });
    const createComponent = () => {
      return component(this.props, this.getComponentContext(true));
    };
    const getRenderFuncion = (componentResult) => new Promise((resolve, reject) => {
      if (typeof componentResult === "function") {
        resolve(componentResult);
      } else if (componentResult instanceof Promise) {
        componentResult.then((render) => {
          resolve(render);
        }).catch((err) => {
          reject(err);
        });
      } else {
        reject(new Error(`Framework7: Component render function is not a "function" type. Didn't you forget to "return $render"?`));
      }
    });
    return new Promise((resolve, reject) => {
      const componentResult = createComponent();
      getRenderFuncion(componentResult).then((render) => {
        this.renderFunction = render;
        const tree = this.render();
        if (el) {
          this.vnode = vdom(tree, this, true);
          if (this.style) {
            this.styleEl = document2.createElement("style");
            this.styleEl.innerHTML = this.style;
          }
          this.el = el;
          patch_default(this.el, this.vnode);
          this.el = this.vnode.elm;
          this.$el = dom7_default(this.el);
          this.attachEvents();
          this.el.f7Component = this;
          this.mount();
          resolve(this);
          return;
        }
        if (tree) {
          this.vnode = vdom(tree, this, true);
          this.el = document2.createElement(this.vnode.sel || "div");
          patch_default(this.el, this.vnode);
          this.$el = dom7_default(this.el);
        }
        if (this.style) {
          this.styleEl = document2.createElement("style");
          this.styleEl.innerHTML = this.style;
        }
        this.attachEvents();
        if (this.el) {
          this.el.f7Component = this;
        }
        resolve(this);
      }).catch((err) => {
        reject(err);
      });
    });
  }
  on(eventName, handler) {
    if (!this.__eventHandlers) return;
    this.__eventHandlers.push({
      eventName,
      handler
    });
  }
  once(eventName, handler) {
    if (!this.__eventHandlers) return;
    this.__onceEventHandlers.push({
      eventName,
      handler
    });
  }
  getComponentRef() {
    const self = this;
    return (initialValue) => {
      let value = initialValue;
      const obj = {};
      Object.defineProperty(obj, "value", {
        get() {
          return value;
        },
        set(v) {
          value = v;
          self.update();
        }
      });
      return obj;
    };
  }
  getComponentStore() {
    const {
      state,
      _gettersPlain,
      dispatch
    } = this.f7.store;
    const $store = {
      state,
      dispatch
    };
    $store.getters = new Proxy(_gettersPlain, {
      get: (target, prop) => {
        const obj = target[prop];
        const callback = (v) => {
          obj.value = v;
          this.update();
        };
        obj.onUpdated(callback);
        return obj;
      }
    });
    return $store;
  }
  /* eslint-disable no-sequences */
  getUseState() {
    var _this = this;
    return (o) => {
      const obj = [o].reduce(function(t2, _i, _x, _a, i) {
        if (i === void 0) {
          i = t2.init(_i);
        }
        return {
          state: i,
          update: (v) => (t2.update(i, v), _this.update()),
          remove: (v) => (t2.remove(i, v), _this.update()),
          clear: () => (t2.clear(i), _this.update()),
          insert: (x, v) => (t2.insert(i, x, v), _this.update()),
          replace: (x, v) => (t2.replace(i, x, v), _this.update()),
          append: (v) => (t2.append(i, v), _this.update()),
          prepend: (v) => (t2.prepend(i, v), _this.update()),
          swap: (a, b) => (t2.swap(i, a, b), _this.update()),
          fromTo: (a, b) => (t2.fromTo(i, a, b), _this.update()),
          method: function(f) {
            if (f === void 0) {
              f = () => ({});
            }
            return f(i), _this.update();
          },
          async: function(f) {
            if (f === void 0) {
              f = () => Promise.reject(i);
            }
            return f(i).then(() => _this.update());
          }
        };
      }, types.find((i) => i.type(o)));
      obj.length = 12;
      obj[Symbol.iterator] = function Iterate() {
        const values = Object.values(this);
        values.splice(values.indexOf(12), 1);
        let index = 0;
        return {
          next() {
            if (index < values.length) {
              const val = values[index];
              index += 1;
              return {
                value: val,
                done: false
              };
            }
            return {
              done: true
            };
          }
        };
      };
      return obj;
    };
  }
  /* eslint-enable no-sequences */
  getComponentContext(includeHooks) {
    const ctx = {
      $f7route: this.context.f7route,
      $f7router: this.context.f7router,
      $h: h_default,
      $: dom7_default,
      $id: this.id,
      $f7: this.f7,
      $f7ready: this.f7ready.bind(this),
      $theme: this.theme,
      $tick: this.tick.bind(this),
      $update: this.update.bind(this),
      $emit: this.emit.bind(this),
      $store: this.getComponentStore(),
      $ref: this.getComponentRef(),
      $el: {},
      $useState: this.getUseState()
    };
    Object.defineProperty(ctx.$el, "value", {
      get: () => {
        return this.$el;
      }
    });
    if (includeHooks) Object.assign(ctx, {
      $on: this.on.bind(this),
      $once: this.once.bind(this),
      $onBeforeMount: (handler) => this.__onBeforeMount.push(handler),
      $onMounted: (handler) => this.__onMounted.push(handler),
      $onBeforeUpdate: (handler) => this.__onBeforeUpdate.push(handler),
      $onUpdated: (handler) => this.__onUpdated.push(handler),
      $onBeforeUnmount: (handler) => this.__onBeforeUnmount.push(handler),
      $onUnmounted: (handler) => this.__onUnmounted.push(handler)
    });
    return ctx;
  }
  render() {
    return this.renderFunction(this.getComponentContext());
  }
  emit(name, data) {
    if (!this.el) return;
    this.$el.trigger(name, data);
  }
  attachEvents() {
    const {
      $el
    } = this;
    if (!this.__eventHandlers) return;
    this.__eventHandlers.forEach((_ref) => {
      let {
        eventName,
        handler
      } = _ref;
      $el.on(eventNameToColonCase(eventName), handler);
    });
    this.__onceEventHandlers.forEach((_ref2) => {
      let {
        eventName,
        handler
      } = _ref2;
      $el.once(eventNameToColonCase(eventName), handler);
    });
  }
  detachEvents() {
    const {
      $el
    } = this;
    if (!this.__eventHandlers) return;
    this.__eventHandlers.forEach((_ref3) => {
      let {
        eventName,
        handler
      } = _ref3;
      $el.on(eventNameToColonCase(eventName), handler);
    });
    this.__onceEventHandlers.forEach((_ref4) => {
      let {
        eventName,
        handler
      } = _ref4;
      $el.once(eventNameToColonCase(eventName), handler);
    });
  }
  startUpdateQueue() {
    const window2 = getWindow();
    if (this.__requestAnimationFrameId) return;
    const update = () => {
      this.hook("onBeforeUpdate");
      const tree = this.render();
      if (tree) {
        const newVNode = vdom(tree, this, false);
        this.vnode = patch_default(this.vnode, newVNode);
      }
    };
    this.__requestAnimationFrameId = window2.requestAnimationFrame(() => {
      if (this.__updateIsPending) update();
      let resolvers = [...this.__updateQueue];
      this.__updateQueue = [];
      this.__updateIsPending = false;
      window2.cancelAnimationFrame(this.__requestAnimationFrameId);
      delete this.__requestAnimationFrameId;
      delete this.__updateIsPending;
      resolvers.forEach((resolver) => resolver());
      resolvers = [];
    });
  }
  tick(callback) {
    return new Promise((resolve) => {
      function resolver() {
        resolve();
        if (callback) callback();
      }
      this.__updateQueue.push(resolver);
      this.startUpdateQueue();
    });
  }
  update(callback) {
    if (this.__destroyed) return new Promise(() => {
    });
    return new Promise((resolve) => {
      const resolver = () => {
        resolve();
        if (callback) callback();
      };
      this.__updateIsPending = true;
      this.__updateQueue.push(resolver);
      this.startUpdateQueue();
    });
  }
  setState(callback) {
    return this.update(callback);
  }
  f7ready(callback) {
    if (this.f7.initialized) {
      callback(this.f7);
      return;
    }
    this.f7.once("init", () => {
      callback(this.f7);
    });
  }
  mount(mountMethod) {
    this.hook("onBeforeMount", this.$el);
    if (this.styleEl) dom7_default("head").append(this.styleEl);
    if (mountMethod) mountMethod(this.el);
    this.hook("onMounted", this.$el);
  }
  destroy() {
    if (this.__destroyed) return;
    const window2 = getWindow();
    this.hook("onBeforeUnmount");
    if (this.styleEl) dom7_default(this.styleEl).remove();
    this.detachEvents();
    this.hook("onUnmounted");
    if (this.el && this.el.f7Component) {
      this.el.f7Component = null;
      delete this.el.f7Component;
    }
    if (this.vnode) {
      this.vnode = patch_default(this.vnode, {
        sel: this.vnode.sel,
        data: {}
      });
    }
    window2.cancelAnimationFrame(this.__requestAnimationFrameId);
    this.__updateQueue = [];
    this.__eventHandlers = [];
    this.__onceEventHandlers = [];
    this.__onBeforeMount = [];
    this.__onMounted = [];
    this.__onBeforeUpdate = [];
    this.__onUpdated = [];
    this.__onBeforeUnmount = [];
    this.__onUnmounted = [];
    deleteProps(this);
    this.__destroyed = true;
  }
  hook(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.__destroyed) return;
    this[`__${name}`].forEach((handler) => {
      handler(...args);
    });
  }
};
Component.$jsx = jsx_default;
var component_class_default = Component;

// node_modules/framework7/modules/component/parse-component.js
function parseComponent(componentString) {
  const window2 = getWindow();
  const document2 = getDocument();
  const componentId = id();
  const callbackCreateName = `f7_component_create_callback_${componentId}`;
  let template;
  const hasTemplate = componentString.match(/<template([ ]?)([a-z0-9-]*)>/);
  if (hasTemplate) {
    template = componentString.split(/<template[ ]?[a-z0-9-]*>/).filter((item, index) => index > 0).join("<template>").split("</template>").filter((item, index, arr) => index < arr.length - 1).join("</template>").replace(/{{#raw}}([ \n]*)<template/g, "{{#raw}}<template").replace(/\/template>([ \n]*){{\/raw}}/g, "/template>{{/raw}}").replace(/([ \n])<template/g, "$1{{#raw}}<template").replace(/\/template>([ \n])/g, "/template>{{/raw}}$1");
  }
  let style = null;
  if (componentString.indexOf("<style>") >= 0) {
    style = componentString.split("<style>")[1].split("</style>")[0];
  }
  if (componentString.indexOf("<style scoped>") >= 0) {
    style = componentString.split("<style scoped>")[1].split("</style>")[0];
  }
  let scriptContent;
  if (componentString.indexOf("<script>") >= 0) {
    const scripts = componentString.split("<script>");
    scriptContent = scripts[scripts.length - 1].split("<\/script>")[0].trim();
  } else {
    scriptContent = "return () => {return $render}";
  }
  if (!scriptContent || !scriptContent.trim()) scriptContent = "return () => {return $render}";
  if (template) {
    scriptContent = scriptContent.replace("$render", `function ($$ctx) {
          var $ = $$ctx.$$;
          var $h = $$ctx.$h;
          var $root = $$ctx.$root;
          var $f7 = $$ctx.$f7;
          var $f7route = $$ctx.$f7route;
          var $f7router = $$ctx.$f7router;
          var $theme = $$ctx.$theme;
          var $update = $$ctx.$update;
          var $store = $$ctx.$store;
          var $ref = $$ctx.$ref;
          var $useState = $$ctx.$useState;

          return $h\`${template}\`
        }
        `).replace(/export default/g, "return");
  }
  scriptContent = `window.${callbackCreateName} = function () {${scriptContent}}`;
  const scriptEl = document2.createElement("script");
  scriptEl.innerHTML = scriptContent;
  dom7_default("head").append(scriptEl);
  const component = window2[callbackCreateName]();
  dom7_default(scriptEl).remove();
  window2[callbackCreateName] = null;
  delete window2[callbackCreateName];
  if (style) {
    component.style = style;
  }
  component.id = componentId;
  return component;
}
var parse_component_default = parseComponent;

// node_modules/framework7/modules/component/component.js
function registerComponent(tagName2, component) {
  custom_components_default[tagName2] = component;
}
function unregisterComponent(tagName2) {
  delete custom_components_default[tagName2];
}
var component_default = {
  name: "component",
  static: {
    Component: component_class_default,
    parseComponent: parse_component_default,
    registerComponent,
    unregisterComponent
  },
  create() {
    const app = this;
    app.component = {
      registerComponent,
      unregisterComponent,
      parse(componentString) {
        return parse_component_default(componentString);
      },
      create(component, props, _ref) {
        let {
          root,
          el,
          context,
          children
        } = _ref;
        return new component_class_default(app, component, props, {
          root,
          el,
          context,
          children
        });
      }
    };
  }
};

// node_modules/framework7/framework7.esm.js
router_class_default.use([component_loader_default]);
app_class_default.use([device_default, support_default, utils_default, resize_default, touch_default, clicks_default, router_default, history_default, component_default, service_worker_default, store_default, statusbar_default, view_default, navbar_default, toolbar_default, subnavbar_default, touch_ripple_default, modal_default]);
var framework7_esm_default = app_class_default;
export {
  jsx_default as $jsx,
  component_class_default as Component,
  dom7_default as Dom7,
  create_store_default as createStore,
  framework7_esm_default as default,
  getDevice,
  getSupport,
  utils_exports as utils
};
//# sourceMappingURL=framework7.js.map
