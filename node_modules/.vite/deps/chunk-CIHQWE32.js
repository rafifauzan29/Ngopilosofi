import {
  framework7_lite_esm_default
} from "./chunk-NN5LJOV2.js";
import {
  Comment,
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  guardReactiveProps,
  inject,
  mergeProps,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onUpdated,
  openBlock,
  ref,
  renderSlot,
  resolveComponent,
  toDisplayString,
  watch,
  withCtx
} from "./chunk-U3LI7FBV.js";

// node_modules/framework7-vue/shared/utils.js
function noUndefinedProps(obj) {
  const o = {};
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] !== "undefined") o[key] = obj[key];
  });
  return o;
}
function isStringProp(val) {
  return typeof val === "string" && val !== "";
}
function isObject(o) {
  return typeof o === "object" && o !== null && o.constructor && o.constructor === Object;
}
function now() {
  return Date.now();
}
function extend() {
  let deep = true;
  let to;
  let from;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[0] === "boolean") {
    [deep, to] = args;
    args.splice(0, 2);
    from = args;
  } else {
    [to] = args;
    args.splice(0, 1);
    from = args;
  }
  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            extend(to[nextKey], nextSource[nextKey]);
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            extend(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function classNames() {
  const classes = [];
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  args.forEach((arg) => {
    if (typeof arg === "object" && arg.constructor === Object) {
      Object.keys(arg).forEach((key) => {
        if (arg[key]) classes.push(key);
      });
    } else if (arg) classes.push(arg);
  });
  const uniqueClasses = [];
  classes.forEach((c) => {
    if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
  });
  return uniqueClasses.join(" ");
}
var routerIdCounter = 0;
var routerComponentIdCounter = 0;
function unsetRouterIds() {
  routerIdCounter = 0;
  routerComponentIdCounter = 0;
}
function getRouterId() {
  routerIdCounter += 1;
  return `${now()}_${routerIdCounter}`;
}
function getComponentId() {
  routerComponentIdCounter += 1;
  return `${now()}_${routerComponentIdCounter}`;
}
function getChildren(slots, slotName) {
  if (slotName === void 0) {
    slotName = "default";
  }
  const result = [];
  const getElementsChildren = (els) => {
    if (!Array.isArray(els)) {
      return;
    }
    els.forEach((vnode) => {
      const isFragment = vnode.type === Fragment;
      if (isFragment && vnode.children) {
        getElementsChildren(vnode.children);
      } else if (vnode.type && vnode.type !== Comment) {
        result.push(vnode);
      }
    });
  };
  if (slots[slotName]) getElementsChildren(slots[slotName]());
  return result;
}

// node_modules/framework7-vue/shared/mixins.js
function colorClasses(props) {
  const {
    color,
    textColor,
    bgColor,
    borderColor,
    rippleColor,
    dark
  } = props;
  return {
    dark,
    [`color-${color}`]: color,
    [`text-color-${textColor}`]: textColor,
    [`bg-color-${bgColor}`]: bgColor,
    [`border-color-${borderColor}`]: borderColor,
    [`ripple-color-${rippleColor}`]: rippleColor
  };
}
var colorProps = {
  color: String,
  colorTheme: String,
  textColor: String,
  bgColor: String,
  borderColor: String,
  rippleColor: String,
  dark: Boolean
};
var iconProps = {
  icon: String,
  iconMaterial: String,
  iconF7: String,
  iconIos: String,
  iconMd: String,
  iconColor: String,
  iconSize: [String, Number],
  iconBadge: [String, Number],
  iconBadgeColor: String
};
var routerProps = {
  back: Boolean,
  external: Boolean,
  force: Boolean,
  animate: {
    type: Boolean,
    default: void 0
  },
  ignoreCache: Boolean,
  reloadCurrent: Boolean,
  reloadAll: Boolean,
  reloadPrevious: Boolean,
  reloadDetail: {
    type: Boolean,
    default: void 0
  },
  routeTabId: String,
  view: String,
  routeProps: Object,
  preventRouter: Boolean,
  transition: String,
  openIn: String
};
function routerAttrs(props) {
  const {
    force,
    reloadCurrent,
    reloadPrevious,
    reloadAll,
    reloadDetail,
    animate,
    ignoreCache,
    routeTabId,
    view,
    transition,
    openIn
  } = props;
  let dataAnimate;
  if ("animate" in props && typeof animate !== "undefined") {
    dataAnimate = animate.toString();
  }
  let dataReloadDetail;
  if ("reloadDetail" in props && typeof reloadDetail !== "undefined") {
    dataReloadDetail = reloadDetail.toString();
  }
  return {
    "data-force": force || void 0,
    "data-reload-current": reloadCurrent || void 0,
    "data-reload-all": reloadAll || void 0,
    "data-reload-previous": reloadPrevious || void 0,
    "data-reload-detail": dataReloadDetail,
    "data-animate": dataAnimate,
    "data-ignore-cache": ignoreCache || void 0,
    "data-route-tab-id": routeTabId || void 0,
    "data-view": isStringProp(view) ? view : void 0,
    "data-transition": isStringProp(transition) ? transition : void 0,
    "data-open-in": isStringProp(openIn) ? openIn : void 0
  };
}
function routerClasses(props) {
  const {
    back,
    linkBack,
    external,
    preventRouter
  } = props;
  return {
    back: back || linkBack,
    external,
    "prevent-router": preventRouter
  };
}
var actionsProps = {
  searchbarEnable: [Boolean, String],
  searchbarDisable: [Boolean, String],
  searchbarClear: [Boolean, String],
  searchbarToggle: [Boolean, String],
  // Panel
  panelOpen: [Boolean, String],
  panelClose: [Boolean, String],
  panelToggle: [Boolean, String],
  // Popup
  popupOpen: [Boolean, String],
  popupClose: [Boolean, String],
  // Actions
  actionsOpen: [Boolean, String],
  actionsClose: [Boolean, String],
  // Popover
  popoverOpen: [Boolean, String],
  popoverClose: [Boolean, String],
  // Login Screen
  loginScreenOpen: [Boolean, String],
  loginScreenClose: [Boolean, String],
  // Picker
  sheetOpen: [Boolean, String],
  sheetClose: [Boolean, String],
  // Sortable
  sortableEnable: [Boolean, String],
  sortableDisable: [Boolean, String],
  sortableToggle: [Boolean, String],
  // Card
  cardOpen: [Boolean, String],
  cardPreventOpen: [Boolean, String],
  cardClose: [Boolean, String]
};
function actionsAttrs(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsOpen,
    actionsClose,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardClose
  } = props;
  return {
    "data-searchbar": isStringProp(searchbarEnable) && searchbarEnable || isStringProp(searchbarDisable) && searchbarDisable || isStringProp(searchbarClear) && searchbarClear || isStringProp(searchbarToggle) && searchbarToggle || void 0,
    "data-panel": isStringProp(panelOpen) && panelOpen || isStringProp(panelClose) && panelClose || isStringProp(panelToggle) && panelToggle || void 0,
    "data-popup": isStringProp(popupOpen) && popupOpen || isStringProp(popupClose) && popupClose || void 0,
    "data-actions": isStringProp(actionsOpen) && actionsOpen || isStringProp(actionsClose) && actionsClose || void 0,
    "data-popover": isStringProp(popoverOpen) && popoverOpen || isStringProp(popoverClose) && popoverClose || void 0,
    "data-sheet": isStringProp(sheetOpen) && sheetOpen || isStringProp(sheetClose) && sheetClose || void 0,
    "data-login-screen": isStringProp(loginScreenOpen) && loginScreenOpen || isStringProp(loginScreenClose) && loginScreenClose || void 0,
    "data-sortable": isStringProp(sortableEnable) && sortableEnable || isStringProp(sortableDisable) && sortableDisable || isStringProp(sortableToggle) && sortableToggle || void 0,
    "data-card": isStringProp(cardOpen) && cardOpen || isStringProp(cardClose) && cardClose || void 0
  };
}
function actionsClasses(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsClose,
    actionsOpen,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardPreventOpen,
    cardClose
  } = props;
  return {
    "searchbar-enable": searchbarEnable || searchbarEnable === "",
    "searchbar-disable": searchbarDisable || searchbarDisable === "",
    "searchbar-clear": searchbarClear || searchbarClear === "",
    "searchbar-toggle": searchbarToggle || searchbarToggle === "",
    "panel-close": panelClose || panelClose === "",
    "panel-open": panelOpen || panelOpen === "",
    "panel-toggle": panelToggle || panelToggle === "",
    "popup-close": popupClose || popupClose === "",
    "popup-open": popupOpen || popupOpen === "",
    "actions-close": actionsClose || actionsClose === "",
    "actions-open": actionsOpen || actionsOpen === "",
    "popover-close": popoverClose || popoverClose === "",
    "popover-open": popoverOpen || popoverOpen === "",
    "sheet-close": sheetClose || sheetClose === "",
    "sheet-open": sheetOpen || sheetOpen === "",
    "login-screen-close": loginScreenClose || loginScreenClose === "",
    "login-screen-open": loginScreenOpen || loginScreenOpen === "",
    "sortable-enable": sortableEnable || sortableEnable === "",
    "sortable-disable": sortableDisable || sortableDisable === "",
    "sortable-toggle": sortableToggle || sortableToggle === "",
    "card-close": cardClose || cardClose === "",
    "card-open": cardOpen || cardOpen === "",
    "card-prevent-open": cardPreventOpen || cardPreventOpen === ""
  };
}

// node_modules/framework7-vue/shared/f7.js
var f7;
var f7events;
var theme = {};
var f7routers = {
  views: [],
  tabs: [],
  modals: null
};
var setTheme = () => {
  if (!f7) return;
  theme.ios = f7.theme === "ios";
  theme.md = f7.theme === "md";
};
var cleanup = () => {
  unsetRouterIds();
  delete theme.ios;
  delete theme.md;
  f7routers.views = [];
  f7routers.tabs = [];
  f7routers.modals = null;
};
var f7initEvents = () => {
  f7events = new framework7_lite_esm_default.Events();
};
var f7init = function(rootEl, params, init) {
  if (params === void 0) {
    params = {};
  }
  if (init === void 0) {
    init = true;
  }
  const f7Params = extend({}, params, {
    el: rootEl,
    init
  });
  if (typeof params.store !== "undefined") f7Params.store = params.store;
  if (!f7Params.routes) f7Params.routes = [];
  if (f7Params.userAgent && (f7Params.theme === "auto" || !f7Params.theme)) {
    const device = framework7_lite_esm_default.getDevice({
      userAgent: f7Params.userAgent
    }, true);
    theme.ios = !!device.ios;
    theme.md = !theme.ios;
  }
  if (f7 && typeof window !== "undefined") return;
  if (typeof window === "undefined") cleanup();
  const instance = new framework7_lite_esm_default(f7Params);
  f7 = instance;
  setTheme();
  if (instance.initialized) {
    f7 = instance;
    f7events.emit("ready", f7);
  } else {
    instance.on("init", () => {
      f7 = instance;
      f7events.emit("ready", f7);
    });
  }
};
var f7ready = (callback) => {
  if (!callback) return;
  if (f7 && f7.initialized) callback(f7);
  else {
    f7events.once("ready", callback);
  }
};

// node_modules/framework7-vue/shared/use-theme.js
var useTheme = () => {
  const t = ref(f7 ? theme : null);
  if (!f7) {
    f7ready(() => {
      t.value = theme;
    });
  }
  return t;
};

// node_modules/framework7-vue/shared/use-icon.js
var useIcon = function(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    icon,
    iconMaterial,
    iconF7,
    iconMd,
    iconIos,
    iconColor,
    iconSize,
    iconBadge,
    badgeColor,
    iconBadgeColor
  } = props;
  if (icon || iconMaterial || iconF7 || iconMd || iconIos) {
    return {
      props: {
        material: iconMaterial,
        f7: iconF7,
        icon,
        md: iconMd,
        ios: iconIos,
        color: iconColor,
        size: iconSize
      },
      badge: iconBadge || iconBadge === 0 ? {
        props: {
          color: badgeColor || iconBadgeColor
        },
        content: iconBadge
      } : null
    };
  }
  return null;
};

// node_modules/framework7-vue/shared/use-route-props.js
var useRouteProps = function(elRef, _temp) {
  let {
    routeProps
  } = _temp === void 0 ? {} : _temp;
  onMounted(() => {
    if (elRef.value && routeProps) {
      elRef.value.f7RouteProps = routeProps;
    }
  });
  onUpdated(() => {
    if (elRef.value && routeProps) {
      elRef.value.f7RouteProps = routeProps;
    } else if (elRef.value && elRef.value.f7RouteProps) {
      delete elRef.value.f7RouteProps;
    }
  });
};

// node_modules/framework7-vue/shared/use-tooltip.js
var useTooltip = (elRef, props) => {
  let f7Tooltip = null;
  const {
    tooltip,
    tooltipTrigger
  } = props;
  onMounted(() => {
    if (!elRef.value) return;
    if (!tooltip) return;
    f7ready(() => {
      f7Tooltip = f7.tooltip.create({
        targetEl: elRef.value,
        text: tooltip,
        trigger: tooltipTrigger
      });
    });
  });
  onBeforeUnmount(() => {
    if (f7Tooltip && f7Tooltip.destroy) {
      f7Tooltip.destroy();
      f7Tooltip = null;
    }
  });
  watch(() => props.tooltip, (value) => {
    if (!value && f7Tooltip) {
      f7Tooltip.destroy();
      f7Tooltip = null;
      return;
    }
    if (value && !f7Tooltip && f7) {
      f7Tooltip = f7.tooltip.create({
        targetEl: elRef.value,
        text: value,
        trigger: tooltipTrigger
      });
      return;
    }
    if (!value || !f7Tooltip) return;
    f7Tooltip.setText(value);
  });
};

// node_modules/framework7-vue/shared/use-smart-select.js
var useSmartSelect = (props, setInstance, getEl) => {
  let f7SmartSelect;
  onMounted(() => {
    f7ready(() => {
      if (props.smartSelect) {
        const ssParams = extend({
          el: getEl()
        }, props.smartSelectParams || {});
        f7SmartSelect = f7.smartSelect.create(ssParams);
        setInstance(f7SmartSelect);
      }
    });
  });
  onBeforeUnmount(() => {
    if (f7SmartSelect && f7SmartSelect.destroy) {
      f7SmartSelect.destroy();
    }
    f7SmartSelect = null;
    setInstance(f7SmartSelect);
  });
};

// node_modules/framework7-vue/components/badge.js
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("span", {
    ref: "elRef",
    class: normalizeClass(_ctx.classes)
  }, [renderSlot(_ctx.$slots, "default")], 2);
}
var badge_default = {
  name: "f7-badge",
  render,
  props: {
    tooltip: String,
    tooltipTrigger: String,
    ...colorProps
  },
  setup(props) {
    const elRef = ref(null);
    useTooltip(elRef, props);
    const classes = computed(() => classNames("badge", colorClasses(props)));
    return {
      elRef,
      classes
    };
  }
};

// node_modules/framework7-vue/components/icon.js
function render2(_ctx, _cache) {
  return openBlock(), createElementBlock("i", {
    ref: "elRef",
    style: normalizeStyle({
      fontSize: _ctx.sizeComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed
    }),
    class: normalizeClass(_ctx.classesComputed)
  }, [createTextVNode(toDisplayString(_ctx.iconText) + " ", 1), renderSlot(_ctx.$slots, "default")], 6);
}
var icon_default = {
  name: "f7-icon",
  render: render2,
  props: {
    material: String,
    f7: String,
    icon: String,
    ios: String,
    md: String,
    tooltip: String,
    tooltipTrigger: String,
    size: [String, Number],
    ...colorProps
  },
  setup(props) {
    const elRef = ref(null);
    const theme2 = useTheme();
    useTooltip(elRef, props);
    const classesComputed = computed(() => {
      const {
        ios,
        md,
        f7: f72,
        material,
        icon
      } = props;
      let classes = {
        icon: true
      };
      let themeIcon;
      if (theme2.value && theme2.value.ios) themeIcon = ios;
      else if (theme2.value && theme2.value.md) themeIcon = md;
      if (themeIcon) {
        const parts = themeIcon.split(":");
        const prop = parts[0];
        const value = parts[1];
        if (prop === "material" || prop === "f7") {
          classes["material-icons"] = prop === "material";
          classes["f7-icons"] = prop === "f7";
        }
        if (prop === "icon") {
          classes[value] = true;
        }
        if (icon) classes[icon] = true;
      } else {
        classes = {
          icon: true,
          "material-icons": material,
          "f7-icons": f72
        };
        if (icon) classes[icon] = true;
      }
      return classNames(classes, colorClasses(props));
    });
    const sizeComputed = computed(() => {
      let size = props.size;
      if (typeof props.size === "number" || parseFloat(props.size) === props.size * 1) {
        size = `${props.size}px`;
      }
      return size;
    });
    const iconText = computed(() => {
      const {
        ios,
        md,
        f7: f72,
        material
      } = props;
      let text = material || f72;
      if (md && theme2.value && theme2.value.md && (md.indexOf("material:") >= 0 || md.indexOf("f7:") >= 0)) {
        text = md.split(":")[1];
      } else if (ios && theme2.value && theme2.value.ios && (ios.indexOf("material:") >= 0 || ios.indexOf("f7:") >= 0)) {
        text = ios.split(":")[1];
      }
      return text;
    });
    return {
      elRef,
      sizeComputed,
      classesComputed,
      iconText
    };
  }
};

// node_modules/framework7-vue/components/use-icon.js
function render3(_ctx, _cache) {
  const _component_f7_badge = resolveComponent("f7-badge");
  const _component_f7_icon = resolveComponent("f7-icon");
  return openBlock(), createBlock(_component_f7_icon, normalizeProps(guardReactiveProps(_ctx.icon.props)), {
    default: withCtx(() => [_ctx.icon.badge ? (openBlock(), createBlock(_component_f7_badge, normalizeProps(mergeProps({
      key: 0
    }, _ctx.icon.badge.props)), {
      default: withCtx(() => [createTextVNode(toDisplayString(_ctx.icon.badge.content), 1)]),
      _: 1
    }, 16)) : createCommentVNode("", true)]),
    _: 1
  }, 16);
}
var use_icon_default = {
  name: "f7-use-icon",
  render: render3,
  components: {
    f7Icon: icon_default,
    f7Badge: badge_default
  },
  props: {
    icon: Object
  }
};

// node_modules/framework7-vue/components/link.js
function render4(_ctx, _cache) {
  const _component_f7_use_icon = resolveComponent("f7-use-icon");
  const _component_f7_badge = resolveComponent("f7-badge");
  return openBlock(), createElementBlock("a", mergeProps({
    ref: "elRef",
    class: _ctx.classes
  }, _ctx.attrs), [_ctx.icon ? (openBlock(), createBlock(_component_f7_use_icon, {
    key: 0,
    icon: _ctx.icon
  }, null, 8, ["icon"])) : createCommentVNode("", true), _ctx.text ? (openBlock(), createElementBlock("span", {
    key: 1,
    class: normalizeClass(_ctx.isTabbarIcons ? "tabbar-label" : "")
  }, [createTextVNode(toDisplayString(_ctx.text) + " ", 1), _ctx.badge ? (openBlock(), createBlock(_component_f7_badge, {
    key: 0,
    color: _ctx.badgeColor
  }, {
    default: withCtx(() => [createTextVNode(toDisplayString(_ctx.badge), 1)]),
    _: 1
  }, 8, ["color"])) : createCommentVNode("", true)], 2)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "default")], 16);
}
var link_default = {
  name: "f7-link",
  render: render4,
  components: {
    f7Badge: badge_default,
    f7UseIcon: use_icon_default
  },
  props: {
    noLinkClass: Boolean,
    text: String,
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    tabbarLabel: Boolean,
    iconOnly: Boolean,
    badge: [String, Number],
    badgeColor: [String],
    href: {
      type: [String, Boolean],
      default: "#"
    },
    target: String,
    tooltip: String,
    tooltipTrigger: String,
    smartSelect: Boolean,
    smartSelectParams: Object,
    ...iconProps,
    ...colorProps,
    ...actionsProps,
    ...routerProps
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const elRef = ref(null);
    let f7SmartSelect = null;
    useTooltip(elRef, props);
    useRouteProps(elRef, props);
    useSmartSelect(props, (instance) => {
      f7SmartSelect = instance;
    }, () => {
      return elRef.value;
    });
    const TabbarContext = inject("TabbarContext", {
      value: {}
    });
    const isTabbarIcons = computed(() => props.tabbarLabel || TabbarContext.value.tabbarHasIcons);
    const attrs = computed(() => {
      const {
        href,
        tabLink,
        target
      } = props;
      let hrefComputed = href;
      if (href === true) hrefComputed = "#";
      if (href === false) hrefComputed = void 0;
      return {
        href: hrefComputed,
        target,
        "data-tab": isStringProp(tabLink) && tabLink || void 0,
        ...routerAttrs(props),
        ...actionsAttrs(props)
      };
    });
    const classes = computed(() => {
      const {
        iconOnly,
        text,
        noLinkClass,
        tabLink,
        tabLinkActive,
        smartSelect
      } = props;
      let iconOnlyComputed;
      const hasChildren = slots && slots.default;
      if (iconOnly || !text && !hasChildren) {
        iconOnlyComputed = true;
      } else {
        iconOnlyComputed = false;
      }
      return classNames({
        link: !(noLinkClass || isTabbarIcons.value),
        "icon-only": iconOnlyComputed,
        "tab-link": tabLink || tabLink === "",
        "tab-link-active": tabLinkActive,
        "smart-select": smartSelect
      }, colorClasses(props), routerClasses(props), actionsClasses(props));
    });
    const icon = computed(() => useIcon(props));
    return {
      elRef,
      icon,
      isTabbarIcons,
      attrs,
      classes,
      f7SmartSelect
    };
  }
};

// node_modules/framework7-vue/components/nav-left.js
function render5(_ctx, _cache) {
  const _component_f7_link = resolveComponent("f7-link");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [_ctx.backLink ? (openBlock(), createBlock(_component_f7_link, {
    key: 0,
    href: _ctx.backLinkUrl || "#",
    back: "",
    icon: "icon-back",
    force: _ctx.backLinkForce || void 0,
    class: normalizeClass(!_ctx.text ? "icon-only" : void 0),
    text: _ctx.text,
    onClick: _ctx.onBackClick
  }, null, 8, ["href", "force", "class", "text", "onClick"])) : createCommentVNode("", true), renderSlot(_ctx.$slots, "default")], 2);
}
var nav_left_default = {
  name: "f7-nav-left",
  render: render5,
  components: {
    f7Link: link_default
  },
  props: {
    backLink: [Boolean, String],
    backLinkUrl: String,
    backLinkForce: Boolean,
    backLinkShowText: {
      type: Boolean,
      default: void 0
    },
    sliding: Boolean,
    ...colorProps
  },
  emits: ["back:click", "click:back"],
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const onBackClick = (event) => {
      emit("back:click", event);
      emit("click:back", event);
    };
    const theme2 = useTheme();
    const text = computed(() => {
      let needBackLinkText = props.backLinkShowText;
      if (typeof needBackLinkText === "undefined") needBackLinkText = !theme2.value.md;
      if (props.backLink) {
        return props.backLink !== true && needBackLinkText ? props.backLink : void 0;
      }
      return void 0;
    });
    const classes = computed(() => classNames("left", {
      sliding: props.sliding
    }, colorClasses(props)));
    return {
      classes,
      onBackClick,
      text
    };
  }
};

// node_modules/framework7-vue/components/nav-title.js
var _hoisted_1 = {
  key: 0,
  class: "subtitle"
};
function render6(_ctx, _cache) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [renderSlot(_ctx.$slots, "default"), createTextVNode(" " + toDisplayString(_ctx.title) + " ", 1), _ctx.subtitle ? (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(_ctx.subtitle), 1)) : createCommentVNode("", true)], 2);
}
var nav_title_default = {
  name: "f7-nav-title",
  render: render6,
  props: {
    title: String,
    subtitle: String,
    sliding: Boolean,
    ...colorProps
  },
  setup(props) {
    const classes = computed(() => classNames("title", {
      sliding: props.sliding
    }, colorClasses(props)));
    return {
      classes
    };
  }
};

// node_modules/framework7-vue/components/nav-right.js
function render7(_ctx, _cache) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [renderSlot(_ctx.$slots, "default")], 2);
}
var nav_right_default = {
  name: "f7-nav-right",
  render: render7,
  props: {
    sliding: Boolean,
    ...colorProps
  },
  setup(props) {
    const classes = computed(() => classNames("right", {
      sliding: props.sliding
    }, colorClasses(props)));
    return {
      classes
    };
  }
};

// node_modules/framework7-vue/components/navbar.js
var _hoisted_12 = createBaseVNode("div", {
  class: "navbar-bg"
}, null, -1);
var _hoisted_2 = {
  key: 3,
  className: "title-large"
};
var _hoisted_3 = {
  className: "title-large-text"
};
function render8(_ctx, _cache) {
  const _component_f7_nav_left = resolveComponent("f7-nav-left");
  const _component_f7_nav_title = resolveComponent("f7-nav-title");
  const _component_f7_nav_right = resolveComponent("f7-nav-right");
  return openBlock(), createElementBlock("div", {
    ref: "elRef",
    class: normalizeClass(_ctx.classes)
  }, [_hoisted_12, renderSlot(_ctx.$slots, "before-inner"), createBaseVNode("div", {
    class: normalizeClass(_ctx.innerClasses)
  }, [_ctx.hasLeft ? (openBlock(), createBlock(_component_f7_nav_left, {
    key: 0,
    "back-link": _ctx.backLink,
    "back-link-url": _ctx.backLinkUrl,
    "back-link-force": _ctx.backLinkForce,
    "back-link-show-text": _ctx.backLinkShowText,
    "onBack:click": _ctx.onBackClick
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "nav-left"), renderSlot(_ctx.$slots, "left")]),
    _: 3
  }, 8, ["back-link", "back-link-url", "back-link-force", "back-link-show-text", "onBack:click"])) : createCommentVNode("", true), _ctx.hasTitle ? (openBlock(), createBlock(_component_f7_nav_title, {
    key: 1,
    title: _ctx.title,
    subtitle: _ctx.subtitle
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "title")]),
    _: 3
  }, 8, ["title", "subtitle"])) : createCommentVNode("", true), _ctx.hasRight ? (openBlock(), createBlock(_component_f7_nav_right, {
    key: 2
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "nav-right"), renderSlot(_ctx.$slots, "right")]),
    _: 3
  })) : createCommentVNode("", true), _ctx.hasLargeTitle ? (openBlock(), createElementBlock("div", _hoisted_2, [createBaseVNode("div", _hoisted_3, [createTextVNode(toDisplayString(_ctx.largeTitle) + " ", 1), renderSlot(_ctx.$slots, "title-large")])])) : createCommentVNode("", true), renderSlot(_ctx.$slots, "default")], 2), renderSlot(_ctx.$slots, "after-inner")], 2);
}
var navbar_default = {
  name: "f7-navbar",
  render: render8,
  components: {
    f7NavLeft: nav_left_default,
    f7NavTitle: nav_title_default,
    f7NavRight: nav_right_default
  },
  props: {
    backLink: [Boolean, String],
    backLinkUrl: String,
    backLinkForce: Boolean,
    backLinkShowText: {
      type: Boolean,
      default: void 0
    },
    sliding: {
      type: Boolean,
      default: true
    },
    title: String,
    subtitle: String,
    hidden: Boolean,
    outline: {
      type: Boolean,
      default: true
    },
    innerClass: String,
    innerClassName: String,
    large: Boolean,
    largeTransparent: Boolean,
    transparent: Boolean,
    titleLarge: String,
    ...colorProps
  },
  emits: ["navbar:hide", "navbar:show", "navbar:expand", "navbar:collapse", "navbar:transparentshow", "navbar:transparenthide", "click:back", "back:click"],
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    let routerPositionClass = "";
    let largeCollapsed = false;
    let routerNavbarRole = null;
    let routerNavbarRoleDetailRoot = false;
    let routerNavbarMasterStack = false;
    let transparentVisible = false;
    const elRef = ref(null);
    const theme2 = useTheme();
    const onHide = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      emit("navbar:hide");
    };
    const onShow = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      emit("navbar:show");
    };
    const onExpand = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      largeCollapsed = false;
      emit("navbar:expand");
    };
    const onCollapse = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      largeCollapsed = true;
      emit("navbar:collapse");
    };
    const onNavbarTransparentShow = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      transparentVisible = true;
      emit("navbar:transparentshow");
    };
    const onNavbarTransparentHide = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      transparentVisible = false;
      emit("navbar:transparenthide");
    };
    const onNavbarPosition = (navbarEl, position) => {
      if (elRef.value !== navbarEl) return;
      routerPositionClass = position ? `navbar-${position}` : "";
    };
    const onNavbarRole = (navbarEl, rolesData) => {
      if (elRef.value !== navbarEl) return;
      routerNavbarRole = rolesData.role;
      routerNavbarRoleDetailRoot = rolesData.detailRoot;
    };
    const onNavbarMasterStack = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      routerNavbarMasterStack = true;
    };
    const onNavbarMasterUnstack = (navbarEl) => {
      if (elRef.value !== navbarEl) return;
      routerNavbarMasterStack = false;
    };
    const hide = (animate) => {
      if (!f7) return;
      f7.navbar.hide(elRef.value, animate);
    };
    const show = (animate) => {
      if (!f7) return;
      f7.navbar.show(elRef.value, animate);
    };
    const size = () => {
      if (!f7) return;
      f7.navbar.size(elRef.value);
    };
    const onBackClick = (event) => {
      emit("back:click", event);
      emit("click:back", event);
    };
    onMounted(() => {
      if (!elRef.value) return;
      f7ready(() => {
        f7.navbar.size(elRef.value);
        f7.on("navbarShow", onShow);
        f7.on("navbarHide", onHide);
        f7.on("navbarCollapse", onCollapse);
        f7.on("navbarExpand", onExpand);
        f7.on("navbarPosition", onNavbarPosition);
        f7.on("navbarRole", onNavbarRole);
        f7.on("navbarMasterStack", onNavbarMasterStack);
        f7.on("navbarMasterUnstack", onNavbarMasterUnstack);
        f7.on("navbarTransparentShow", onNavbarTransparentShow);
        f7.on("navbarTransparentHide", onNavbarTransparentHide);
      });
    });
    onBeforeUnmount(() => {
      if (!f7) return;
      f7.off("navbarShow", onShow);
      f7.off("navbarHide", onHide);
      f7.off("navbarCollapse", onCollapse);
      f7.off("navbarExpand", onExpand);
      f7.off("navbarPosition", onNavbarPosition);
      f7.off("navbarRole", onNavbarRole);
      f7.off("navbarMasterStack", onNavbarMasterStack);
      f7.off("navbarMasterUnstack", onNavbarMasterUnstack);
      f7.off("navbarTransparentShow", onNavbarTransparentShow);
      f7.off("navbarTransparentHide", onNavbarTransparentHide);
    });
    const addLeftTitleClass = computed(() => theme2.value && theme2.value.ios && f7 && !f7.params.navbar.iosCenterTitle);
    const addCenterTitleClass = computed(() => theme2.value && theme2.value.md && f7 && f7.params.navbar.mdCenterTitle);
    const isLarge = computed(() => props.large || props.largeTransparent);
    const isTransparent = computed(() => props.transparent || isLarge.value && props.largeTransparent);
    const isTransparentVisible = computed(() => isTransparent.value && transparentVisible);
    const classes = computed(() => classNames("navbar", routerPositionClass, {
      "navbar-hidden": props.hidden,
      "navbar-large": isLarge.value,
      "navbar-large-collapsed": isLarge.value && largeCollapsed,
      "navbar-transparent": isTransparent.value,
      "navbar-transparent-visible": isTransparentVisible.value,
      "navbar-master": routerNavbarRole === "master",
      "navbar-master-detail": routerNavbarRole === "detail",
      "navbar-master-detail-root": routerNavbarRoleDetailRoot === true,
      "navbar-master-stacked": routerNavbarMasterStack === true,
      "no-outline": !props.outline
    }, colorClasses(props)));
    const largeTitle = computed(() => {
      let largeTitleText = props.titleLarge;
      if (!largeTitleText && props.large && props.title) largeTitleText = props.title;
      return largeTitleText;
    });
    const hasLeft = computed(() => {
      return props.backLink || slots["nav-left"] || slots.left;
    });
    const hasTitle = computed(() => {
      return props.title || props.subtitle || slots.title;
    });
    const hasRight = computed(() => {
      return slots["nav-right"] || slots.right;
    });
    const hasLargeTitle = computed(() => {
      return largeTitle.value || slots["title-large"];
    });
    const innerClasses = computed(() => {
      return classNames("navbar-inner", props.innerClass, props.innerClassName, {
        sliding: props.sliding,
        "navbar-inner-left-title": addLeftTitleClass.value,
        "navbar-inner-centered-title": addCenterTitleClass.value
      });
    });
    return {
      elRef,
      classes,
      innerClasses,
      hide,
      show,
      size,
      largeTitle,
      hasLeft,
      hasTitle,
      hasRight,
      hasLargeTitle,
      onBackClick
    };
  }
};

export {
  noUndefinedProps,
  isStringProp,
  extend,
  classNames,
  getRouterId,
  getComponentId,
  getChildren,
  colorClasses,
  colorProps,
  iconProps,
  routerProps,
  routerAttrs,
  routerClasses,
  actionsProps,
  actionsAttrs,
  actionsClasses,
  f7,
  f7events,
  theme,
  f7routers,
  setTheme,
  f7initEvents,
  f7init,
  f7ready,
  useTheme,
  useIcon,
  useRouteProps,
  useTooltip,
  useSmartSelect,
  badge_default,
  icon_default,
  use_icon_default,
  link_default,
  nav_left_default,
  nav_title_default,
  nav_right_default,
  navbar_default
};
//# sourceMappingURL=chunk-CIHQWE32.js.map
